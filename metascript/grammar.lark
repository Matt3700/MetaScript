// Expanded Meta Script grammar â€” now includes pattern matching, async/await, and macros
// This remains intentionally permissive so the fallback parser can support a
// useful subset without external dependencies; the Lark grammar is the
// authoritative spec for future toolchains.

start: program
program: statement*

statement: simple_stmt | compound_stmt | cobol_stmt

simple_stmt: say_stmt
           | print_stmt
           | let_stmt
           | assign_stmt
           | return_stmt
           | expr_stmt

compound_stmt: if_stmt
             | while_stmt
             | for_stmt
             | def_stmt
             | async_def
             | do_stmt
             | agent_call
             | match_stmt
             | macro_def

say_stmt: "say" WS? expr
print_stmt: "print" WS? expr

let_stmt: "let" NAME "=" expr
assign_stmt: NAME "=" expr
return_stmt: "return" expr

if_stmt: "if" expr ":" block ("else" ":" block)?
while_stmt: "while" expr ":" block
for_stmt: "for" NAME "in" expr ":" block

def_stmt: "def" NAME "(" [param_list] ")" ":" block
async_def: "async" def_stmt
param_list: NAME ("," NAME)*

do_stmt: "do" ":" block

agent_call: "agent" NAME "[" STRING "]"

// Pattern matching (lightweight)
match_stmt: "match" expr ":" match_case+
match_case: "case" pattern ":" block
pattern: "_"                        -> wildcard_pattern
       | NAME                        -> name_pattern
       | INT                         -> int_pattern
       | STRING                      -> string_pattern
       | "[" [pattern ("," pattern)*] "]"   -> list_pattern

// Macros (compile-time-like helpers; treated as functions in runtime transpiler)
macro_def: "macro" NAME "(" [param_list] ")" ":" block
macro_call: "@" NAME "(" [arg_list] ")"

block: single_statement | braced_block
single_statement: statement
braced_block: "{" statement* "}"

// expressions + await support
expr: or_expr
?or_expr: and_expr ("or" and_expr)*
?and_expr: cmp_expr ("and" cmp_expr)*
?cmp_expr: sum_expr (("==" | "!=" | "<" | ">" | "<=" | ">=") sum_expr)?
?sum_expr: sum_expr "+" mul_expr   -> add
         | sum_expr "-" mul_expr   -> sub
         | mul_expr
?mul_expr: mul_expr "*" atom       -> mul
         | mul_expr "/" atom       -> div
         | atom
range_literal: INT ".." INT

?atom: "await" atom               -> await_expr
     | STRING                      -> string
     | INT                         -> int
     | NAME                        -> name
     | range_literal                -> range_literal
     | list_literal
     | function_call
     | "(" expr ")"

list_literal: "[" [expr ("," expr)*] "]"

function_call: NAME "(" [arg_list] ")"
arg_list: expr ("," expr)*

// COBOL-style statements (informative surface mapping to same AST semantics)
cobol_stmt: "DISPLAY" WS? STRING "."
          | "COMPUTE" WS NAME "=" expr "."
          | "STOP" WS "RUN" "."

%import common.CNAME -> NAME
%import common.INT
%import common.ESCAPED_STRING -> STRING
%import common.WS_INLINE -> WS
%ignore WS_INLINE
COMMENT: /#.*/
%ignore COMMENT

